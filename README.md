# Geant4_jll.jl

This is an autogenerated package constructed using [`BinaryBuilder.jl`](https://github.com/JuliaPackaging/BinaryBuilder.jl).

## Products

The code bindings within this package are autogenerated from the following `Products` defined within the `build_tarballs.jl` file that generated this package:

```julia
products = [
    LibraryProduct(["libG4Tree"], :libG4Tree),
    LibraryProduct(["libG4tracking"], :libG4Tracking),
    LibraryProduct(["libG4digits_hits"], :libG4Digits),
    LibraryProduct(["libG4analysis"], :libG4Analysis),
    LibraryProduct(["libG4geometry"], :libG4Geometry),
    LibraryProduct(["libG4particles"], :libG4Particles),
    LibraryProduct(["libG4modeling"], :libG4Modeling),
    LibraryProduct(["libG4persistency"], :libG4Persistency),
    LibraryProduct(["libG4FR"], :libG4FR),
    LibraryProduct(["libG4visXXX"], :libG4VisXXX),
    LibraryProduct(["libG4interfaces"], :libG4Interfaces),
    LibraryProduct(["libG4GMocren"], :libG4Mocren),
    LibraryProduct(["libG4RayTracer"], :libG4RayTracer),
    LibraryProduct(["libG4global"], :libG4Global),
    LibraryProduct(["libG4parmodels"], :libG4ParModels),
    LibraryProduct(["libG4VRML"], :libG4VRML),
    LibraryProduct(["libG4run"], :libG4Run),
    LibraryProduct(["libG4readout"], :libG4Readout),
    LibraryProduct(["libG4processes"], :libG4Processes),
    LibraryProduct(["libG4intercoms"], :libG4Intercoms),
    LibraryProduct(["libG4event"], :libG4Event),
    LibraryProduct(["libG4materials"], :libG4Material),
    LibraryProduct(["libG4zlib"], :libG4Zlib),
    LibraryProduct(["libG4error_propagation"], :libG4ErrorPropagation),
    LibraryProduct(["libG4physicslists"], :libG4PhysicsLists),
    LibraryProduct(["libG4vis_management"], :libG4visManagement),
    LibraryProduct(["libG4visHepRep"], :libG4VisHepRep),
    LibraryProduct(["libG4graphics_reps"], :libG4Graphics),
    LibraryProduct(["libG4track"], :libG4Track),
    LibraryProduct(["libG4clhep"], :libG4CLHEP)
]
```

## Usage example

For example purposes, we will assume that the following products were defined in the imaginary package `Example_jll`:

```julia
products = [
    FileProduct("src/data.txt", :data_txt),
    LibraryProduct("libdataproc", :libdataproc),
    ExecutableProduct("mungify", :mungify_exe)
]
```

With such products defined, `Example_jll` would contain `data_txt`, `libdataproc` and `mungify_exe` symbols exported. For `FileProduct` variables, the exported value is a string pointing to the location of the file on-disk.  For `LibraryProduct` variables, it is a string corresponding to the `SONAME` of the desired library (it will have already been `dlopen()`'ed, so typical `ccall()` usage applies), and for `ExecutableProduct` variables, the exported value is a function that can be called to set appropriate environment variables.  Example:

```julia
using Example_jll

# For file products, you can access its file location directly:
data_lines = open(data_txt, "r") do io
    readlines(io)
end

# For library products, you can use the exported variable name in `ccall()` invocations directly
num_chars = ccall((:count_characters, libdataproc), Cint, (Cstring, Cint), data_lines[1], length(data_lines[1]))

# For executable products, you can use the exported variable name as a function that you can call
mungify_exe() do mungify_exe_path
    run(`$mungify_exe_path $num_chars`)
end
```
