# Autogenerated wrapper script for Geant4_jll for x86_64-apple-darwin14
export libG4Tree, libG4Tracking, libG4Digits, libG4Analysis, libG4Geometry, libG4Particles, libG4Modeling, libG4Persistency, libG4FR, libG4VisXXX, libG4Interfaces, libG4Mocren, libG4RayTracer, libG4Global, libG4ParModels, libG4VRML, libG4Run, libG4Readout, libG4Processes, libG4Intercoms, libG4Event, libG4Material, libG4Zlib, libG4ErrorPropagation, libG4PhysicsLists, libG4visManagement, libG4VisHepRep, libG4Graphics, libG4Track, libG4CLHEP

using Expat_jll
## Global variables
PATH = ""
LIBPATH = ""
LIBPATH_env = "DYLD_FALLBACK_LIBRARY_PATH"

# Relative path to `libG4Tree`
const libG4Tree_splitpath = ["lib", "libG4Tree.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Tree_path = ""

# libG4Tree-specific global declaration
# This will be filled out by __init__()
libG4Tree_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Tree = "@rpath/libG4Tree.dylib"


# Relative path to `libG4Tracking`
const libG4Tracking_splitpath = ["lib", "libG4tracking.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Tracking_path = ""

# libG4Tracking-specific global declaration
# This will be filled out by __init__()
libG4Tracking_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Tracking = "@rpath/libG4tracking.dylib"


# Relative path to `libG4Digits`
const libG4Digits_splitpath = ["lib", "libG4digits_hits.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Digits_path = ""

# libG4Digits-specific global declaration
# This will be filled out by __init__()
libG4Digits_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Digits = "@rpath/libG4digits_hits.dylib"


# Relative path to `libG4Analysis`
const libG4Analysis_splitpath = ["lib", "libG4analysis.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Analysis_path = ""

# libG4Analysis-specific global declaration
# This will be filled out by __init__()
libG4Analysis_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Analysis = "@rpath/libG4analysis.dylib"


# Relative path to `libG4Geometry`
const libG4Geometry_splitpath = ["lib", "libG4geometry.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Geometry_path = ""

# libG4Geometry-specific global declaration
# This will be filled out by __init__()
libG4Geometry_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Geometry = "@rpath/libG4geometry.dylib"


# Relative path to `libG4Particles`
const libG4Particles_splitpath = ["lib", "libG4particles.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Particles_path = ""

# libG4Particles-specific global declaration
# This will be filled out by __init__()
libG4Particles_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Particles = "@rpath/libG4particles.dylib"


# Relative path to `libG4Modeling`
const libG4Modeling_splitpath = ["lib", "libG4modeling.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Modeling_path = ""

# libG4Modeling-specific global declaration
# This will be filled out by __init__()
libG4Modeling_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Modeling = "@rpath/libG4modeling.dylib"


# Relative path to `libG4Persistency`
const libG4Persistency_splitpath = ["lib", "libG4persistency.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Persistency_path = ""

# libG4Persistency-specific global declaration
# This will be filled out by __init__()
libG4Persistency_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Persistency = "@rpath/libG4persistency.dylib"


# Relative path to `libG4FR`
const libG4FR_splitpath = ["lib", "libG4FR.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4FR_path = ""

# libG4FR-specific global declaration
# This will be filled out by __init__()
libG4FR_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4FR = "@rpath/libG4FR.dylib"


# Relative path to `libG4VisXXX`
const libG4VisXXX_splitpath = ["lib", "libG4visXXX.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4VisXXX_path = ""

# libG4VisXXX-specific global declaration
# This will be filled out by __init__()
libG4VisXXX_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4VisXXX = "@rpath/libG4visXXX.dylib"


# Relative path to `libG4Interfaces`
const libG4Interfaces_splitpath = ["lib", "libG4interfaces.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Interfaces_path = ""

# libG4Interfaces-specific global declaration
# This will be filled out by __init__()
libG4Interfaces_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Interfaces = "@rpath/libG4interfaces.dylib"


# Relative path to `libG4Mocren`
const libG4Mocren_splitpath = ["lib", "libG4GMocren.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Mocren_path = ""

# libG4Mocren-specific global declaration
# This will be filled out by __init__()
libG4Mocren_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Mocren = "@rpath/libG4GMocren.dylib"


# Relative path to `libG4RayTracer`
const libG4RayTracer_splitpath = ["lib", "libG4RayTracer.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4RayTracer_path = ""

# libG4RayTracer-specific global declaration
# This will be filled out by __init__()
libG4RayTracer_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4RayTracer = "@rpath/libG4RayTracer.dylib"


# Relative path to `libG4Global`
const libG4Global_splitpath = ["lib", "libG4global.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Global_path = ""

# libG4Global-specific global declaration
# This will be filled out by __init__()
libG4Global_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Global = "@rpath/libG4global.dylib"


# Relative path to `libG4ParModels`
const libG4ParModels_splitpath = ["lib", "libG4parmodels.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4ParModels_path = ""

# libG4ParModels-specific global declaration
# This will be filled out by __init__()
libG4ParModels_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4ParModels = "@rpath/libG4parmodels.dylib"


# Relative path to `libG4VRML`
const libG4VRML_splitpath = ["lib", "libG4VRML.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4VRML_path = ""

# libG4VRML-specific global declaration
# This will be filled out by __init__()
libG4VRML_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4VRML = "@rpath/libG4VRML.dylib"


# Relative path to `libG4Run`
const libG4Run_splitpath = ["lib", "libG4run.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Run_path = ""

# libG4Run-specific global declaration
# This will be filled out by __init__()
libG4Run_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Run = "@rpath/libG4run.dylib"


# Relative path to `libG4Readout`
const libG4Readout_splitpath = ["lib", "libG4readout.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Readout_path = ""

# libG4Readout-specific global declaration
# This will be filled out by __init__()
libG4Readout_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Readout = "@rpath/libG4readout.dylib"


# Relative path to `libG4Processes`
const libG4Processes_splitpath = ["lib", "libG4processes.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Processes_path = ""

# libG4Processes-specific global declaration
# This will be filled out by __init__()
libG4Processes_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Processes = "@rpath/libG4processes.dylib"


# Relative path to `libG4Intercoms`
const libG4Intercoms_splitpath = ["lib", "libG4intercoms.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Intercoms_path = ""

# libG4Intercoms-specific global declaration
# This will be filled out by __init__()
libG4Intercoms_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Intercoms = "@rpath/libG4intercoms.dylib"


# Relative path to `libG4Event`
const libG4Event_splitpath = ["lib", "libG4event.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Event_path = ""

# libG4Event-specific global declaration
# This will be filled out by __init__()
libG4Event_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Event = "@rpath/libG4event.dylib"


# Relative path to `libG4Material`
const libG4Material_splitpath = ["lib", "libG4materials.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Material_path = ""

# libG4Material-specific global declaration
# This will be filled out by __init__()
libG4Material_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Material = "@rpath/libG4materials.dylib"


# Relative path to `libG4Zlib`
const libG4Zlib_splitpath = ["lib", "libG4zlib.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Zlib_path = ""

# libG4Zlib-specific global declaration
# This will be filled out by __init__()
libG4Zlib_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Zlib = "@rpath/libG4zlib.dylib"


# Relative path to `libG4ErrorPropagation`
const libG4ErrorPropagation_splitpath = ["lib", "libG4error_propagation.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4ErrorPropagation_path = ""

# libG4ErrorPropagation-specific global declaration
# This will be filled out by __init__()
libG4ErrorPropagation_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4ErrorPropagation = "@rpath/libG4error_propagation.dylib"


# Relative path to `libG4PhysicsLists`
const libG4PhysicsLists_splitpath = ["lib", "libG4physicslists.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4PhysicsLists_path = ""

# libG4PhysicsLists-specific global declaration
# This will be filled out by __init__()
libG4PhysicsLists_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4PhysicsLists = "@rpath/libG4physicslists.dylib"


# Relative path to `libG4visManagement`
const libG4visManagement_splitpath = ["lib", "libG4vis_management.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4visManagement_path = ""

# libG4visManagement-specific global declaration
# This will be filled out by __init__()
libG4visManagement_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4visManagement = "@rpath/libG4vis_management.dylib"


# Relative path to `libG4VisHepRep`
const libG4VisHepRep_splitpath = ["lib", "libG4visHepRep.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4VisHepRep_path = ""

# libG4VisHepRep-specific global declaration
# This will be filled out by __init__()
libG4VisHepRep_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4VisHepRep = "@rpath/libG4visHepRep.dylib"


# Relative path to `libG4Graphics`
const libG4Graphics_splitpath = ["lib", "libG4graphics_reps.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Graphics_path = ""

# libG4Graphics-specific global declaration
# This will be filled out by __init__()
libG4Graphics_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Graphics = "@rpath/libG4graphics_reps.dylib"


# Relative path to `libG4Track`
const libG4Track_splitpath = ["lib", "libG4track.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4Track_path = ""

# libG4Track-specific global declaration
# This will be filled out by __init__()
libG4Track_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4Track = "@rpath/libG4track.dylib"


# Relative path to `libG4CLHEP`
const libG4CLHEP_splitpath = ["lib", "libG4clhep.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libG4CLHEP_path = ""

# libG4CLHEP-specific global declaration
# This will be filled out by __init__()
libG4CLHEP_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libG4CLHEP = "@rpath/libG4clhep.dylib"


"""
Open all libraries
"""
function __init__()
    global artifact_dir = abspath(artifact"Geant4")

    # Initialize PATH and LIBPATH environment variable listings
    global PATH_list, LIBPATH_list
    # We first need to add to LIBPATH_list the libraries provided by Julia
    append!(LIBPATH_list, [joinpath(Sys.BINDIR, Base.LIBDIR, "julia"), joinpath(Sys.BINDIR, Base.LIBDIR)])
    # From the list of our dependencies, generate a tuple of all the PATH and LIBPATH lists,
    # then append them to our own.
    foreach(p -> append!(PATH_list, p), (Expat_jll.PATH_list,))
    foreach(p -> append!(LIBPATH_list, p), (Expat_jll.LIBPATH_list,))

    global libG4Tree_path = normpath(joinpath(artifact_dir, libG4Tree_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Tree_handle = dlopen(libG4Tree_path)
    push!(LIBPATH_list, dirname(libG4Tree_path))

    global libG4Tracking_path = normpath(joinpath(artifact_dir, libG4Tracking_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Tracking_handle = dlopen(libG4Tracking_path)
    push!(LIBPATH_list, dirname(libG4Tracking_path))

    global libG4Digits_path = normpath(joinpath(artifact_dir, libG4Digits_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Digits_handle = dlopen(libG4Digits_path)
    push!(LIBPATH_list, dirname(libG4Digits_path))

    global libG4Analysis_path = normpath(joinpath(artifact_dir, libG4Analysis_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Analysis_handle = dlopen(libG4Analysis_path)
    push!(LIBPATH_list, dirname(libG4Analysis_path))

    global libG4Geometry_path = normpath(joinpath(artifact_dir, libG4Geometry_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Geometry_handle = dlopen(libG4Geometry_path)
    push!(LIBPATH_list, dirname(libG4Geometry_path))

    global libG4Particles_path = normpath(joinpath(artifact_dir, libG4Particles_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Particles_handle = dlopen(libG4Particles_path)
    push!(LIBPATH_list, dirname(libG4Particles_path))

    global libG4Modeling_path = normpath(joinpath(artifact_dir, libG4Modeling_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Modeling_handle = dlopen(libG4Modeling_path)
    push!(LIBPATH_list, dirname(libG4Modeling_path))

    global libG4Persistency_path = normpath(joinpath(artifact_dir, libG4Persistency_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Persistency_handle = dlopen(libG4Persistency_path)
    push!(LIBPATH_list, dirname(libG4Persistency_path))

    global libG4FR_path = normpath(joinpath(artifact_dir, libG4FR_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4FR_handle = dlopen(libG4FR_path)
    push!(LIBPATH_list, dirname(libG4FR_path))

    global libG4VisXXX_path = normpath(joinpath(artifact_dir, libG4VisXXX_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4VisXXX_handle = dlopen(libG4VisXXX_path)
    push!(LIBPATH_list, dirname(libG4VisXXX_path))

    global libG4Interfaces_path = normpath(joinpath(artifact_dir, libG4Interfaces_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Interfaces_handle = dlopen(libG4Interfaces_path)
    push!(LIBPATH_list, dirname(libG4Interfaces_path))

    global libG4Mocren_path = normpath(joinpath(artifact_dir, libG4Mocren_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Mocren_handle = dlopen(libG4Mocren_path)
    push!(LIBPATH_list, dirname(libG4Mocren_path))

    global libG4RayTracer_path = normpath(joinpath(artifact_dir, libG4RayTracer_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4RayTracer_handle = dlopen(libG4RayTracer_path)
    push!(LIBPATH_list, dirname(libG4RayTracer_path))

    global libG4Global_path = normpath(joinpath(artifact_dir, libG4Global_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Global_handle = dlopen(libG4Global_path)
    push!(LIBPATH_list, dirname(libG4Global_path))

    global libG4ParModels_path = normpath(joinpath(artifact_dir, libG4ParModels_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4ParModels_handle = dlopen(libG4ParModels_path)
    push!(LIBPATH_list, dirname(libG4ParModels_path))

    global libG4VRML_path = normpath(joinpath(artifact_dir, libG4VRML_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4VRML_handle = dlopen(libG4VRML_path)
    push!(LIBPATH_list, dirname(libG4VRML_path))

    global libG4Run_path = normpath(joinpath(artifact_dir, libG4Run_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Run_handle = dlopen(libG4Run_path)
    push!(LIBPATH_list, dirname(libG4Run_path))

    global libG4Readout_path = normpath(joinpath(artifact_dir, libG4Readout_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Readout_handle = dlopen(libG4Readout_path)
    push!(LIBPATH_list, dirname(libG4Readout_path))

    global libG4Processes_path = normpath(joinpath(artifact_dir, libG4Processes_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Processes_handle = dlopen(libG4Processes_path)
    push!(LIBPATH_list, dirname(libG4Processes_path))

    global libG4Intercoms_path = normpath(joinpath(artifact_dir, libG4Intercoms_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Intercoms_handle = dlopen(libG4Intercoms_path)
    push!(LIBPATH_list, dirname(libG4Intercoms_path))

    global libG4Event_path = normpath(joinpath(artifact_dir, libG4Event_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Event_handle = dlopen(libG4Event_path)
    push!(LIBPATH_list, dirname(libG4Event_path))

    global libG4Material_path = normpath(joinpath(artifact_dir, libG4Material_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Material_handle = dlopen(libG4Material_path)
    push!(LIBPATH_list, dirname(libG4Material_path))

    global libG4Zlib_path = normpath(joinpath(artifact_dir, libG4Zlib_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Zlib_handle = dlopen(libG4Zlib_path)
    push!(LIBPATH_list, dirname(libG4Zlib_path))

    global libG4ErrorPropagation_path = normpath(joinpath(artifact_dir, libG4ErrorPropagation_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4ErrorPropagation_handle = dlopen(libG4ErrorPropagation_path)
    push!(LIBPATH_list, dirname(libG4ErrorPropagation_path))

    global libG4PhysicsLists_path = normpath(joinpath(artifact_dir, libG4PhysicsLists_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4PhysicsLists_handle = dlopen(libG4PhysicsLists_path)
    push!(LIBPATH_list, dirname(libG4PhysicsLists_path))

    global libG4visManagement_path = normpath(joinpath(artifact_dir, libG4visManagement_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4visManagement_handle = dlopen(libG4visManagement_path)
    push!(LIBPATH_list, dirname(libG4visManagement_path))

    global libG4VisHepRep_path = normpath(joinpath(artifact_dir, libG4VisHepRep_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4VisHepRep_handle = dlopen(libG4VisHepRep_path)
    push!(LIBPATH_list, dirname(libG4VisHepRep_path))

    global libG4Graphics_path = normpath(joinpath(artifact_dir, libG4Graphics_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Graphics_handle = dlopen(libG4Graphics_path)
    push!(LIBPATH_list, dirname(libG4Graphics_path))

    global libG4Track_path = normpath(joinpath(artifact_dir, libG4Track_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4Track_handle = dlopen(libG4Track_path)
    push!(LIBPATH_list, dirname(libG4Track_path))

    global libG4CLHEP_path = normpath(joinpath(artifact_dir, libG4CLHEP_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libG4CLHEP_handle = dlopen(libG4CLHEP_path)
    push!(LIBPATH_list, dirname(libG4CLHEP_path))

    # Filter out duplicate and empty entries in our PATH and LIBPATH entries
    filter!(!isempty, unique!(PATH_list))
    filter!(!isempty, unique!(LIBPATH_list))
    global PATH = join(PATH_list, ':')
    global LIBPATH = join(LIBPATH_list, ':')

    # Add each element of LIBPATH to our DL_LOAD_PATH (necessary on platforms
    # that don't honor our "already opened" trick)
    #for lp in LIBPATH_list
    #    push!(DL_LOAD_PATH, lp)
    #end
end  # __init__()

